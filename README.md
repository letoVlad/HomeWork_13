# Обоснование выбора ConcurrentHashMap и ReentrantLock

## Почему ConcurrentHashMap?
`ConcurrentHashMap` заменяет `HashMap` для обеспечения потокобезопасного доступа к кэшу. В отличие от `HashMap`, который не предназначен для использования в многопоточной среде, `ConcurrentHashMap`:
- Разделяет данные на сегменты, снижая количество блокировок.
- Позволяет нескольким потокам одновременно читать данные.
- Обеспечивает более высокую производительность при частом чтении и записи.

Это оптимальное решение для конкурентного доступа, если основная цель - избежать полной блокировки кэша.

## Почему ReentrantLock для элементов кэша?
`ReentrantLock` используется для обеспечения контроля доступа на уровне отдельного элемента кэша. Это позволяет:
1. Заблокировать доступ только к одному элементу кэша при его добавлении или удалении.
2. Избежать ситуации, когда весь кэш блокируется из-за одной операции.

### Как это работает?
Каждый элемент кэша может иметь свой уникальный `ReentrantLock`. Перед добавлением или удалением элемента:
- Поток захватывает блокировку (`lock`) для конкретного элемента.
- После выполнения операции блокировка освобождается (`unlock`).

### Преимущества подхода:
1. **Локальная блокировка**: Исключается конкуренция между потоками за весь кэш.
2. **Масштабируемость**: Обеспечивает более плавную работу при большом количестве потоков.
3. **Простота чтения**: Чтение данных из `ConcurrentHashMap` остаётся неблокирующим.
